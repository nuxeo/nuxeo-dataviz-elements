<!--
(C) Copyright 2016 Nuxeo SA (http://nuxeo.com/) and contributors.

All rights reserved. This program and the accompanying materials
are made available under the terms of the GNU Lesser General Public License
(LGPL) version 2.1 which accompanies this distribution, and is available at
http://www.gnu.org/licenses/lgpl.html

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.

Contributors:
  Guillaume Renard <grenard@nuxeo.com>
-->
<link rel="import" href="../nuxeo-elements/nuxeo-connection.html">
<link rel="import" href="../iron-ajax/iron-request.html">
<link rel="import" href="../iron-ajax/iron-request.html">
<link rel="import" href="../paper-radio-group/paper-radio-group.html">
<link rel="import" href="../paper-checkbox/paper-checkbox.html">
<script src="../d3/d3.min.js"></script>
<script src="../randomcolor/randomColor.js"></script>

<!--
A sunburst chart presenting Nuxeo Disk Usage.

Example:

    <nuxeo-disk-usage pathDepth="7"
      mode="count"
      chartHue="red" chartLumonisity="light">
    </nuxeo-disk-usage>

@group Nuxeo Data Elements
@element nuxeo-disk-usage
@demo demo/diskUsage.html
-->
<dom-module id="nuxeo-disk-usage">
  <template>

    <style is="custom-style">
      #du {
        font-family: 'Open Sans', sans-serif;
        font-size: 12px;
        font-weight: 400;
        width: 100%;
        height: 700px;
        margin-top: 10px;
      }

      #main {
        float: left;
        width: 70%;
      }

      #sb {
        float: right;
        width: 30%;
      }

      #sequence {
        width: 600px;
        height: 70px;
      }

      #legend {
        padding: 10px 0 0 3px;
      }

      #sequence text, #legend text {
        font-weight: 600;
        fill: #fff;
      }

      #chart {
        position: relative;
      }

      #chart path {
        stroke: #fff;
      }

      #ex {
        position: absolute;
        top: 260px;
        left: 305px;
        width: 140px;
        text-align: center;
        color: #666;
        z-index: -1;
      }

      #cl {
        font-size: 2.5em;
      }

    </style>

    <nuxeo-connection id="nx" connection-id="[[connectionId]]"></nuxeo-connection>

    <div id="du">
      <div id="main">
        <div id="sequence"></div>
        <div id="chart">
          <div id="ex" style="visibility: hidden;">
            <span id="cl"></span><br/>
            <span id="clb"></span>
          </div>
        </div>
      </div>
      <div id="sb">
        <paper-radio-group selected="{{mode}}" on-paper-radio-group-changed="execute">
          <paper-radio-button name="size">Size</paper-radio-button>
          <paper-radio-button name="count">Document Count</paper-radio-button>
        </paper-radio-group>
        <paper-checkbox on-tap="_toggleLegend">Legend</paper-checkbox>
        <div id="legend" style="visibility: hidden;"></div>
      </div>
    </div>

  </template>

  <script>
    (function() {

      Polymer({
        is: 'nuxeo-disk-usage',

        properties: {
          /**
           * The id of a nuxeo-connection to use.
           */
          connectionId: {
            type: String,
            value: 'nx'
          },

          index: {
            type: String,
            value: 'nuxeo'
          },

          mode: {
            type: String,
            value: 'size'
          },

          pathDepth: {
            type: Number,
            value: 10
          },

          chartLuminosity: {
            type: String,
            value: 'light'
          },

          chartHue: {
            type: String,
            value: 'blue'
          },

          width: {
            type: Number,
            value: 750
          },

          height: {
            type: Number,
            value: 600
          }

        },

        _computeSizeQuery: function () {
          var query;
          var subPart = {
            "size": {
              "sum": {
                "field": "common:size"
              }
            }
          };
          for (var depth = this.pathDepth; depth > 2; depth--) {
            subPart = {
              "size": {
                "sum": {
                  "field": "common:size"
                }
              },
              "subLevel": {
                "terms": {
                  "field": "pathLevel" + depth,
                  "size": 0
                },
                "aggs": subPart
              }
            };
          }
          query = {
            "query": {
              "filtered": {
                "query": {
                  "query_string": {
                    "query": "-ecm.mixInType.HiddenInNavigation",
                    "analyze_wildcard": true
                  }
                }
              }
            },
            "size": 0,
            "aggs": {
              "subLevel": {
                "terms": {
                  "field": "pathLevel2",
                  "size": 0
                },
                "aggs": subPart
              }
            }
          }
          return query;
        },

        _computeDocCountQuery: function () {
          var query;
          var subPart = {
            "subLevel": {
              "terms": {
                "field": "pathLevel" + this.pathDepth,
                "size": 0,
                "order": {
                  "_count": "desc"
                }
              }
            }
          };
          for (var depth = this.pathDepth - 1; depth > 1; depth--) {
            subPart = {
              "subLevel": {
                "terms": {
                  "field": "pathLevel" + depth,
                  "size": 0,
                  "order": {
                    "_count": "desc"
                  }
                },
                "aggs": subPart
              }
            };
          }
          query = {
            "query": {
              "filtered": {
                "query": {
                  "query_string": {
                    "query": "-ecm.mixInType.HiddenInNavigation",
                    "analyze_wildcard": true
                  }
                }
              }
            },
            "size": 0,
            "aggs": subPart
          }
          return query;
        },

        execute: function() {
          var query;
          if (this.mode === 'size') {
            query = this._computeSizeQuery();
          } else if (this.mode === 'count') {
            query = this._computeDocCountQuery();
          } else {
            alert('Mode must be either size or docCount');
            return;
          }
          var url = [this.$.nx.client._baseURL, 'site/es', this.index, '_search'].join('/');
          url = url.replace(/(^\/+)|([^:])\/\/+/g, '$2/');

          if (this.type) { url += '?search_type=' + this.type; }

          // add auth headers
          var auth = {'Content-Type': 'application/json'};
          this.$.nx.client._computeAuthentication(auth);

          // Normalize headers in lower case
          var headers = {};
          for (var header in auth) {
            headers[header.toLowerCase()] = auth[header].toString();
          }

          return document.createElement('iron-request')
              .send({
                url: url,
                method: 'POST',
                headers: headers,
                body: query,
                handleAs: 'json'
              }).then(this._handleResponse.bind(this)).catch(this._handleError.bind(this));
        },

        _handleError: function(reason) {
          console.error(reason);
          this.fire('error', {
            reason: reason,
            error: reason
          });
        },

        _handleResponse: function(request) {
          var response = request.response;
          return this._buildSunBurst(response.aggregations);
        },

        _transformSubBuckets: function(bucket) {
          bucket.name = bucket.key;
          bucket.color = this._getColor(bucket.name, this.chartHue, this.chartLuminosity);
          var size;
          if (this.mode === 'size') {
            size = bucket.size.value;
            delete bucket.size;
          } else if (this.mode === 'count') {
            size = bucket.doc_count;
            delete bucket.doc_count;
          }
          delete bucket.key;
          bucket.size = size;
          if (bucket.subLevel) {
            bucket.children = bucket.subLevel.buckets;
            delete bucket.subLevel;
            if (bucket.children.length == 0) {
              return;
            }
            for (var j = 0; j < bucket.children.length; j++) {
              this._transformSubBuckets(bucket.children[j]);
            }
          }
        },

        _buildSunBurst: function(aggregations) {
          console.log('_buildSunBurst');
          var aggregations = aggregations.subLevel;
          aggregations.name = "root";
          aggregations.color = this._getColor(aggregations.name, this.chartHue, this.chartLuminosity);
          aggregations.children = aggregations.buckets;
          delete aggregations.buckets;
          delete aggregations.doc_count_error_upper_bound;
          delete aggregations.sum_other_doc_count;
          for (var i = 0; i < aggregations.children.length; i++) {
            this._transformSubBuckets(aggregations.children[i]);
          }

          // Dimensions of sunburst.
          radius = Math.min(this.width, this.height) / 2;

          // Total size of all segments; we set this later, after loading the data.
          var totalSize = 0;
          $(this.$.chart).find('svg').remove();

          vis = d3.select("#chart").append("svg:svg")
              .attr("width", this.width)
              .attr("height", this.height)
              .append("svg:g")
              .attr("id", "container")
              .attr("transform", "translate(" + this.width / 2 + "," + this.height / 2 + ")");

          partition = d3.layout.partition()
              .size([2 * Math.PI, radius * radius])
              .value(function(d) { return d.size; });

          arc = d3.svg.arc()
              .startAngle(function(d) { return d.x; })
              .endAngle(function(d) { return d.x + d.dx; })
              .innerRadius(function(d) { return Math.sqrt(d.y); })
              .outerRadius(function(d) { return Math.sqrt(d.y + d.dy); });

          this._createVisualization(aggregations);

        },

        _getColor: function(pathPart, hue, luminosity) {
          var result = colors[pathPart];
          if (result === undefined) {
            result = randomColor({
              hue: hue,
              luminosity: luminosity
            });
            colors[pathPart] = result;
          }
          return result;
        },

        // Given a node in a partition layout, return an array of all of its ancestor
        // nodes, highest first, but excluding the root.
        _getAncestors: function(node) {
          var path = [];
          var current = node;
          while (current.parent) {
            path.unshift(current);
            current = current.parent;
          }
          return path;
        },

        // Update the breadcrumb trail to show the current sequence and percentage.
        _updateBreadcrumbs: function(nodeArray, percentageString) {

          // Data join; key function combines name and depth (= position in sequence).
          var g = d3.select("#trail")
              .selectAll("g")
              .data(nodeArray, function(d) { return d.name + d.depth; });

          // Add breadcrumb and label for entering nodes.
          var entering = g.enter().append("svg:g");

          entering.append("svg:polygon")
              .attr("points", this._breadcrumbPoints)
              .style("fill", function(d) { return d.color; });

          entering.append("svg:text")
              .attr("x", (b.w + b.t) / 2)
              .attr("y", b.h / 2)
              .attr("dy", "0.35em")
              .attr("text-anchor", "middle")
              .text(function(d) { return d.name; });

          // Set position for entering and updating nodes.
          g.attr("transform", function(d, i) {
            return "translate(" + i * (b.w + b.s) + ", 0)";
          });

          // Remove exiting nodes.
          g.exit().remove();

          // Now move and update the percentage at the end.
          d3.select("#trail").select("#endlabel")
              .attr("x", (nodeArray.length + 0.5) * (b.w + b.s))
              .attr("y", b.h / 2)
              .attr("dy", "0.35em")
              .attr("text-anchor", "middle")
              .text(percentageString);

          // Make the breadcrumb trail visible, if it's hidden.
          d3.select("#trail")
              .style("visibility", "");

        },

        // Main function to draw and set up the visualization, once we have the data.
        _createVisualization: function(aggregations) {

          this._initializeBreadcrumbTrail();
          this._drawLegend();

          // Bounding circle underneath the sunburst, to make it easier to detect
          // when the mouse leaves the parent g.
          vis.append("svg:circle")
              .attr("r", radius)
              .style("opacity", 0);

          // For efficiency, filter nodes to keep only those large enough to see.
          var nodes = partition.nodes(aggregations)
              .filter(function(d) {
              return (d.dx > 0.005); // 0.005 radians = 0.29 degrees
              });

          var path = vis.data([aggregations]).selectAll("path")
              .data(nodes)
              .enter().append("svg:path")
              .attr("display", function(d) { return d.depth ? null : "none"; })
              .attr("d", arc)
              .attr("fill-rule", "evenodd")
              .style("fill", function(d) {
                return d.color;
              })
              .style("opacity", 1)
              .on("mouseover", this._mouseover.bind(this));

          // Add the mouseleave handler to the bounding circle.
          d3.select("#container").on("mouseleave", this._mouseleave);

          // Get total size of the tree = value of root node from partition.
          totalSize = path.node().__data__.value;
        },

        // Fade all but the current sequence, and show it in the breadcrumb trail.
        _mouseover: function(d) {

          var percentage = (100 * d.value / totalSize).toPrecision(3);
          var percentageString = percentage + "%";
          if (percentage < 0.1) {
            percentageString = "< 0.1%";
          }

          d3.select("#cl")
              .text(this._formatValue(d.value, true));
          d3.select("#clb")
              .text('(' + percentageString + ')');

          d3.select("#ex")
              .style("visibility", "");

          var sequenceArray = this._getAncestors(d);
          this._updateBreadcrumbs(sequenceArray, percentageString);

          // Fade all the segments.
          d3.selectAll("path")
              .style("opacity", 0.3);

          // Then highlight only those that are an ancestor of the current segment.
          vis.selectAll("path")
              .filter(function(node) {
                        return (sequenceArray.indexOf(node) >= 0);
                      })
              .style("opacity", 1);
        },

        // Restore everything to full opacity when moving off the visualization.
        _mouseleave: function(d) {
          return;
          // Hide the breadcrumb trail
          d3.select("#trail")
              .style("visibility", "hidden");

          // Deactivate all segments during transition.
          d3.selectAll("path").on("mouseover", null);

          // Transition each segment to full opacity and then reactivate it.
          d3.selectAll("path")
              .transition()
              .duration(1000)
              .style("opacity", 1)
              .each("end", function() {
                      d3.select(this).on("mouseover", this._mouseover.bind(this));
                    });

          d3.select("#ex")
              .style("visibility", "hidden");
        },

        _initializeBreadcrumbTrail: function() {
          $(this.$.sequence).empty()
          // Add the svg area.
          var trail = d3.select("#sequence").append("svg:svg")
              .attr("width", this.width)
              .attr("height", 50)
              .attr("id", "trail");
          // Add the label at the end, for the percentage.
          trail.append("svg:text")
            .attr("id", "endlabel")
            .style("fill", "#000");
        },

        // Generate a string that describes the points of a breadcrumb polygon.
        _breadcrumbPoints: function(d, i) {
          var points = [];
          points.push("0,0");
          points.push(b.w + ",0");
          points.push(b.w + b.t + "," + (b.h / 2));
          points.push(b.w + "," + b.h);
          points.push("0," + b.h);
          if (i > 0) { // Leftmost breadcrumb; don't include 6th vertex.
            points.push(b.t + "," + (b.h / 2));
          }
          return points.join(" ");
        },

        _drawLegend: function() {

          $(this.$.legend).empty();

          // Dimensions of legend item: width, height, spacing, radius of rounded rect.
          var li = {
            w: 100, h: 30, s: 3, r: 3
          };

          var legend = d3.select("#legend").append("svg:svg")
              .attr("width", li.w)
              .attr("height", d3.keys(colors).length * (li.h + li.s));

          var g = legend.selectAll("g")
              .data(d3.entries(colors))
              .enter().append("svg:g")
              .attr("transform", function(d, i) {
                      return "translate(0," + i * (li.h + li.s) + ")";
                   });

          g.append("svg:rect")
              .attr("rx", li.r)
              .attr("ry", li.r)
              .attr("width", li.w)
              .attr("height", li.h)
              .style("fill", function(d) { return d.value; });

          g.append("svg:text")
              .attr("x", li.w / 2)
              .attr("y", li.h / 2)
              .attr("dy", "0.35em")
              .attr("text-anchor", "middle")
              .text(function(d) { return d.key; });
        },

        _toggleLegend: function() {
          var legend = d3.select("#legend");
          if (legend.style("visibility") == "hidden") {
            legend.style("visibility", "");
          } else {
            legend.style("visibility", "hidden");
          }
        },

        _formatValue: function(value, si) {
          if (this.mode === 'size') {
            var thresh = si ? 1000 : 1024;
            if(Math.abs(value) < thresh) {
                return value + ' B';
            }
            var units = si
                ? ['kB','MB','GB','TB','PB','EB','ZB','YB']
                : ['KiB','MiB','GiB','TiB','PiB','EiB','ZiB','YiB'];
            var u = -1;
            do {
                value /= thresh;
                ++u;
            } while(Math.abs(value) >= thresh && u < units.length - 1);
            return value.toFixed(1)+' '+units[u];
          } else if (this.mode === 'count') {
            var result = value + ' Document';
            if (value > 1) {
              result += 's';
            }
            return result;
          } else {
            return value;
          }
        },

        ready: function() {
          this.execute();
        }

      });

      var vis, radius, partition, arc;

      // Breadcrumb dimensions: width, height, spacing, width of tip/tail.
      var b = {
        w: 100, h: 30, s: 3, t: 10
      };

      var colors = {};

    })();
  </script>

</dom-module>
